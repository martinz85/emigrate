import { NextRequest, NextResponse } from 'next/server'
import { createAdminClient } from '@/lib/supabase/server'

/**
 * API Route: /api/purchases/[token]
 * 
 * Validates a purchase access token and returns the purchased content.
 * Token is generated by /api/my-purchases and sent via email.
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { token: string } }
) {
  try {
    const { token } = params

    if (!token) {
      return NextResponse.json(
        { error: 'Token ist erforderlich' },
        { status: 400 }
      )
    }

    const supabase = createAdminClient()

    // ============================================
    // 1. Fetch and validate token
    // ============================================
    const { data: tokenData, error: tokenError } = await supabase
      .from('purchase_access_tokens')
      .select('*')
      .eq('token', token)
      .single()

    if (tokenError || !tokenData) {
      console.error('Token not found:', tokenError)
      return NextResponse.json(
        { error: 'Ung√ºltiger oder abgelaufener Link' },
        { status: 404 }
      )
    }

    // Check if token is expired
    const expiresAt = new Date(tokenData.expires_at)
    if (expiresAt < new Date()) {
      return NextResponse.json(
        { error: 'Dieser Link ist abgelaufen. Bitte fordere einen neuen Link an.' },
        { status: 410 } // 410 Gone
      )
    }

    // ============================================
    // 2. Update token usage stats
    // ============================================
    const now = new Date().toISOString()
    await supabase
      .from('purchase_access_tokens')
      .update({
        used_at: tokenData.used_at || now, // Only set on first use
        access_count: (tokenData.access_count || 0) + 1,
        last_accessed_at: now,
      })
      .eq('token', token)

    // ============================================
    // 3. Fetch analyses
    // ============================================
    const analysisIds = tokenData.analysis_ids || []
    const analyses = []

    if (analysisIds.length > 0) {
      const { data: analysesData, error: analysesError } = await supabase
        .from('analyses')
        .select('id, created_at, paid_at')
        .in('id', analysisIds)
        .eq('paid', true)

      if (!analysesError && analysesData) {
        analyses.push(...analysesData)
      }
    }

    // ============================================
    // 4. Fetch e-books
    // ============================================
    const ebookIds = tokenData.ebook_ids || []
    const ebooks = []

    if (ebookIds.length > 0) {
      const { data: guestPurchases, error: ebooksError } = await supabase
        .from('guest_purchases')
        .select(`
          id,
          purchased_at,
          ebook_id,
          ebooks (
            id,
            title,
            slug
          )
        `)
        .eq('email', tokenData.email)
        .in('ebook_id', ebookIds)
        .is('claimed_at', null)

      if (!ebooksError && guestPurchases) {
        for (const purchase of guestPurchases) {
          if (purchase.ebooks) {
            ebooks.push({
              id: purchase.ebook_id,
              title: (purchase.ebooks as any).title,
              slug: (purchase.ebooks as any).slug,
              purchased_at: purchase.purchased_at,
            })
          }
        }
      }
    }

    // ============================================
    // 5. Return purchases
    // ============================================
    return NextResponse.json({
      email: tokenData.email,
      analyses,
      ebooks,
      expiresAt: tokenData.expires_at,
    })

  } catch (error) {
    console.error('Purchases Access API Error:', error)
    
    const message = error instanceof Error 
      ? error.message 
      : 'Ein unerwarteter Fehler ist aufgetreten'

    return NextResponse.json(
      { error: message },
      { status: 500 }
    )
  }
}

